/** Declaration file generated by dts-gen */

export class bn {
    constructor(it: any);

    add(that: any): any;

    addM(that: any): any;

    bitLength(): any;

    cnormalize(): any;

    copy(): any;

    doubleM(): any;

    equals(that: any): any;

    fullReduce(): any;

    getLimb(i: any): any;

    greaterEquals(that: any): any;

    halveM(): any;

    initWith(it: any): any;

    inverseMod(p: any): any;

    mod(that: any): any;

    montpowermod(x: any, N: any): any;

    mul(that: any): any;

    mulmod(that: any, N: any): any;

    normalize(): any;

    power(l: any): any;

    powermod(x: any, N: any): any;

    reduce(): any;

    square(): any;

    sub(that: any): any;

    subM(that: any): any;

    toBits(len: any): any;

    toString(): any;

    trim(): any;

    static fromBits(bits: any): any;

    static pseudoMersennePrime(exponent: any, coeff: any): any;

    static random(modulus: any, paranoia: any): any;

}

export class prng {
    constructor(defaultParanoia: any);

    addEntropy(data: any, estimatedEntropy: any, source: any): void;

    addEventListener(name: any, callback: any): void;

    getProgress(paranoia: any): any;

    isReady(paranoia: any): any;

    randomWords(nwords: any, paranoia: any): any;

    removeEventListener(name: any, cb: any): void;

    setDefaultParanoia(paranoia: any, allowZeroParanoia: any): void;

    startCollectors(): void;

    stopCollectors(): void;

}

export const codec: {
    arrayBuffer: {
        fromBits: any;
        hexDumpBuffer: any;
        toBits: any;
    };
    base64: {
        fromBits: any;
        toBits: any;
    };
    base64url: {
        fromBits: any;
        toBits: any;
    };
    bytes: {
        fromBits: any;
        toBits: any;
    };
    hex: {
        fromBits: any;
        toBits: any;
    };
    utf8String: {
        fromBits: any;
        toBits: any;
    };
};

export const keyexchange: {
};

export const mode: {
    ccm: {
        decrypt: any;
        encrypt: any;
        listenProgress: any;
        name: string;
        unListenProgress: any;
    };
};

export function decrypt(password: any, ciphertext: any, params: any, rp: any): any;

export function encrypt(password: any, plaintext: any, params: any, rp: any, ...args: any[]): any;

export namespace bitArray {
    function bitLength(a: any): any;

    function bitSlice(a: any, bstart: any, bend: any): any;

    function byteswapM(a: any): any;

    function clamp(a: any, len: any): any;

    function concat(a1: any, a2: any): any;

    function equal(a: any, b: any): any;

    function extract(a: any, bstart: any, blength: any): any;

    function getPartial(x: any): any;

    function partial(len: any, x: any, _end: any): any;

}

export namespace bn {
    namespace prime {
        class p127 {
            constructor(it: any);

            fullReduce(): any;

            inverse(): any;

            reduce(): any;

            static fromBits(bits: any): any;

        }

        class p192 {
            constructor(it: any);

            fullReduce(): any;

            inverse(): any;

            reduce(): any;

            static fromBits(bits: any): any;

        }

        class p192k {
            constructor(it: any);

            fullReduce(): any;

            inverse(): any;

            reduce(): any;

            static fromBits(bits: any): any;

        }

        class p224 {
            constructor(it: any);

            fullReduce(): any;

            inverse(): any;

            reduce(): any;

            static fromBits(bits: any): any;

        }

        class p224k {
            constructor(it: any);

            fullReduce(): any;

            inverse(): any;

            reduce(): any;

            static fromBits(bits: any): any;

        }

        class p25519 {
            constructor(it: any);

            fullReduce(): any;

            inverse(): any;

            reduce(): any;

            static fromBits(bits: any): any;

        }

        class p256 {
            constructor(it: any);

            fullReduce(): any;

            inverse(): any;

            reduce(): any;

            static fromBits(bits: any): any;

        }

        class p256k {
            constructor(it: any);

            fullReduce(): any;

            inverse(): any;

            reduce(): any;

            static fromBits(bits: any): any;

        }

        class p384 {
            constructor(it: any);

            fullReduce(): any;

            inverse(): any;

            reduce(): any;

            static fromBits(bits: any): any;

        }

        class p521 {
            constructor(it: any);

            fullReduce(): any;

            inverse(): any;

            reduce(): any;

            static fromBits(bits: any): any;

        }

        namespace p127 {
            namespace modulus {
                // Too-deep object hierarchy from sjcl.bn.prime.p127.modulus
                const add: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p127.modulus
                const addM: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p127.modulus
                const bitLength: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p127.modulus
                const cnormalize: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p127.modulus
                const copy: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p127.modulus
                const doubleM: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p127.modulus
                const equals: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p127.modulus
                const fullReduce: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p127.modulus
                const getLimb: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p127.modulus
                const greaterEquals: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p127.modulus
                const halveM: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p127.modulus
                const initWith: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p127.modulus
                const inverseMod: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p127.modulus
                const ipv: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p127.modulus
                const limbs: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p127.modulus
                const maxMul: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p127.modulus
                const mod: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p127.modulus
                const montpowermod: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p127.modulus
                const mul: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p127.modulus
                const mulmod: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p127.modulus
                const normalize: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p127.modulus
                const placeVal: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p127.modulus
                const power: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p127.modulus
                const powermod: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p127.modulus
                const radix: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p127.modulus
                const radixMask: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p127.modulus
                const reduce: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p127.modulus
                const square: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p127.modulus
                const sub: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p127.modulus
                const subM: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p127.modulus
                const toBits: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p127.modulus
                const toString: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p127.modulus
                const trim: any;

            }

        }

        namespace p192 {
            namespace modulus {
                // Too-deep object hierarchy from sjcl.bn.prime.p192.modulus
                const add: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p192.modulus
                const addM: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p192.modulus
                const bitLength: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p192.modulus
                const cnormalize: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p192.modulus
                const copy: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p192.modulus
                const doubleM: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p192.modulus
                const equals: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p192.modulus
                const fullReduce: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p192.modulus
                const getLimb: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p192.modulus
                const greaterEquals: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p192.modulus
                const halveM: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p192.modulus
                const initWith: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p192.modulus
                const inverseMod: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p192.modulus
                const ipv: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p192.modulus
                const limbs: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p192.modulus
                const maxMul: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p192.modulus
                const mod: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p192.modulus
                const montpowermod: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p192.modulus
                const mul: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p192.modulus
                const mulmod: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p192.modulus
                const normalize: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p192.modulus
                const placeVal: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p192.modulus
                const power: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p192.modulus
                const powermod: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p192.modulus
                const radix: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p192.modulus
                const radixMask: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p192.modulus
                const reduce: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p192.modulus
                const square: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p192.modulus
                const sub: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p192.modulus
                const subM: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p192.modulus
                const toBits: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p192.modulus
                const toString: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p192.modulus
                const trim: any;

            }

        }

        namespace p192k {
            namespace modulus {
                // Too-deep object hierarchy from sjcl.bn.prime.p192k.modulus
                const add: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p192k.modulus
                const addM: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p192k.modulus
                const bitLength: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p192k.modulus
                const cnormalize: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p192k.modulus
                const copy: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p192k.modulus
                const doubleM: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p192k.modulus
                const equals: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p192k.modulus
                const fullReduce: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p192k.modulus
                const getLimb: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p192k.modulus
                const greaterEquals: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p192k.modulus
                const halveM: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p192k.modulus
                const initWith: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p192k.modulus
                const inverseMod: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p192k.modulus
                const ipv: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p192k.modulus
                const limbs: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p192k.modulus
                const maxMul: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p192k.modulus
                const mod: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p192k.modulus
                const montpowermod: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p192k.modulus
                const mul: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p192k.modulus
                const mulmod: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p192k.modulus
                const normalize: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p192k.modulus
                const placeVal: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p192k.modulus
                const power: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p192k.modulus
                const powermod: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p192k.modulus
                const radix: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p192k.modulus
                const radixMask: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p192k.modulus
                const reduce: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p192k.modulus
                const square: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p192k.modulus
                const sub: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p192k.modulus
                const subM: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p192k.modulus
                const toBits: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p192k.modulus
                const toString: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p192k.modulus
                const trim: any;

            }

        }

        namespace p224 {
            namespace modulus {
                // Too-deep object hierarchy from sjcl.bn.prime.p224.modulus
                const add: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p224.modulus
                const addM: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p224.modulus
                const bitLength: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p224.modulus
                const cnormalize: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p224.modulus
                const copy: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p224.modulus
                const doubleM: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p224.modulus
                const equals: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p224.modulus
                const fullReduce: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p224.modulus
                const getLimb: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p224.modulus
                const greaterEquals: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p224.modulus
                const halveM: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p224.modulus
                const initWith: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p224.modulus
                const inverseMod: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p224.modulus
                const ipv: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p224.modulus
                const limbs: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p224.modulus
                const maxMul: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p224.modulus
                const mod: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p224.modulus
                const montpowermod: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p224.modulus
                const mul: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p224.modulus
                const mulmod: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p224.modulus
                const normalize: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p224.modulus
                const placeVal: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p224.modulus
                const power: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p224.modulus
                const powermod: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p224.modulus
                const radix: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p224.modulus
                const radixMask: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p224.modulus
                const reduce: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p224.modulus
                const square: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p224.modulus
                const sub: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p224.modulus
                const subM: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p224.modulus
                const toBits: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p224.modulus
                const toString: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p224.modulus
                const trim: any;

            }

        }

        namespace p224k {
            namespace modulus {
                // Too-deep object hierarchy from sjcl.bn.prime.p224k.modulus
                const add: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p224k.modulus
                const addM: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p224k.modulus
                const bitLength: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p224k.modulus
                const cnormalize: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p224k.modulus
                const copy: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p224k.modulus
                const doubleM: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p224k.modulus
                const equals: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p224k.modulus
                const fullReduce: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p224k.modulus
                const getLimb: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p224k.modulus
                const greaterEquals: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p224k.modulus
                const halveM: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p224k.modulus
                const initWith: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p224k.modulus
                const inverseMod: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p224k.modulus
                const ipv: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p224k.modulus
                const limbs: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p224k.modulus
                const maxMul: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p224k.modulus
                const mod: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p224k.modulus
                const montpowermod: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p224k.modulus
                const mul: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p224k.modulus
                const mulmod: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p224k.modulus
                const normalize: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p224k.modulus
                const placeVal: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p224k.modulus
                const power: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p224k.modulus
                const powermod: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p224k.modulus
                const radix: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p224k.modulus
                const radixMask: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p224k.modulus
                const reduce: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p224k.modulus
                const square: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p224k.modulus
                const sub: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p224k.modulus
                const subM: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p224k.modulus
                const toBits: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p224k.modulus
                const toString: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p224k.modulus
                const trim: any;

            }

        }

        namespace p25519 {
            namespace modulus {
                // Too-deep object hierarchy from sjcl.bn.prime.p25519.modulus
                const add: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p25519.modulus
                const addM: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p25519.modulus
                const bitLength: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p25519.modulus
                const cnormalize: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p25519.modulus
                const copy: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p25519.modulus
                const doubleM: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p25519.modulus
                const equals: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p25519.modulus
                const fullReduce: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p25519.modulus
                const getLimb: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p25519.modulus
                const greaterEquals: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p25519.modulus
                const halveM: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p25519.modulus
                const initWith: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p25519.modulus
                const inverseMod: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p25519.modulus
                const ipv: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p25519.modulus
                const limbs: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p25519.modulus
                const maxMul: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p25519.modulus
                const mod: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p25519.modulus
                const montpowermod: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p25519.modulus
                const mul: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p25519.modulus
                const mulmod: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p25519.modulus
                const normalize: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p25519.modulus
                const placeVal: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p25519.modulus
                const power: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p25519.modulus
                const powermod: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p25519.modulus
                const radix: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p25519.modulus
                const radixMask: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p25519.modulus
                const reduce: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p25519.modulus
                const square: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p25519.modulus
                const sub: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p25519.modulus
                const subM: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p25519.modulus
                const toBits: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p25519.modulus
                const toString: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p25519.modulus
                const trim: any;

            }

        }

        namespace p256 {
            namespace modulus {
                // Too-deep object hierarchy from sjcl.bn.prime.p256.modulus
                const add: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p256.modulus
                const addM: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p256.modulus
                const bitLength: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p256.modulus
                const cnormalize: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p256.modulus
                const copy: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p256.modulus
                const doubleM: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p256.modulus
                const equals: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p256.modulus
                const fullReduce: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p256.modulus
                const getLimb: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p256.modulus
                const greaterEquals: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p256.modulus
                const halveM: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p256.modulus
                const initWith: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p256.modulus
                const inverseMod: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p256.modulus
                const ipv: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p256.modulus
                const limbs: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p256.modulus
                const maxMul: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p256.modulus
                const mod: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p256.modulus
                const montpowermod: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p256.modulus
                const mul: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p256.modulus
                const mulmod: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p256.modulus
                const normalize: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p256.modulus
                const placeVal: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p256.modulus
                const power: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p256.modulus
                const powermod: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p256.modulus
                const radix: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p256.modulus
                const radixMask: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p256.modulus
                const reduce: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p256.modulus
                const square: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p256.modulus
                const sub: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p256.modulus
                const subM: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p256.modulus
                const toBits: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p256.modulus
                const toString: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p256.modulus
                const trim: any;

            }

        }

        namespace p256k {
            namespace modulus {
                // Too-deep object hierarchy from sjcl.bn.prime.p256k.modulus
                const add: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p256k.modulus
                const addM: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p256k.modulus
                const bitLength: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p256k.modulus
                const cnormalize: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p256k.modulus
                const copy: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p256k.modulus
                const doubleM: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p256k.modulus
                const equals: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p256k.modulus
                const fullReduce: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p256k.modulus
                const getLimb: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p256k.modulus
                const greaterEquals: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p256k.modulus
                const halveM: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p256k.modulus
                const initWith: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p256k.modulus
                const inverseMod: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p256k.modulus
                const ipv: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p256k.modulus
                const limbs: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p256k.modulus
                const maxMul: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p256k.modulus
                const mod: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p256k.modulus
                const montpowermod: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p256k.modulus
                const mul: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p256k.modulus
                const mulmod: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p256k.modulus
                const normalize: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p256k.modulus
                const placeVal: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p256k.modulus
                const power: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p256k.modulus
                const powermod: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p256k.modulus
                const radix: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p256k.modulus
                const radixMask: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p256k.modulus
                const reduce: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p256k.modulus
                const square: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p256k.modulus
                const sub: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p256k.modulus
                const subM: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p256k.modulus
                const toBits: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p256k.modulus
                const toString: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p256k.modulus
                const trim: any;

            }

        }

        namespace p384 {
            namespace modulus {
                // Too-deep object hierarchy from sjcl.bn.prime.p384.modulus
                const add: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p384.modulus
                const addM: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p384.modulus
                const bitLength: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p384.modulus
                const cnormalize: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p384.modulus
                const copy: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p384.modulus
                const doubleM: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p384.modulus
                const equals: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p384.modulus
                const fullReduce: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p384.modulus
                const getLimb: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p384.modulus
                const greaterEquals: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p384.modulus
                const halveM: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p384.modulus
                const initWith: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p384.modulus
                const inverseMod: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p384.modulus
                const ipv: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p384.modulus
                const limbs: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p384.modulus
                const maxMul: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p384.modulus
                const mod: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p384.modulus
                const montpowermod: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p384.modulus
                const mul: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p384.modulus
                const mulmod: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p384.modulus
                const normalize: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p384.modulus
                const placeVal: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p384.modulus
                const power: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p384.modulus
                const powermod: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p384.modulus
                const radix: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p384.modulus
                const radixMask: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p384.modulus
                const reduce: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p384.modulus
                const square: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p384.modulus
                const sub: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p384.modulus
                const subM: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p384.modulus
                const toBits: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p384.modulus
                const toString: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p384.modulus
                const trim: any;

            }

        }

        namespace p521 {
            namespace modulus {
                // Too-deep object hierarchy from sjcl.bn.prime.p521.modulus
                const add: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p521.modulus
                const addM: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p521.modulus
                const bitLength: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p521.modulus
                const cnormalize: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p521.modulus
                const copy: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p521.modulus
                const doubleM: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p521.modulus
                const equals: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p521.modulus
                const fullReduce: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p521.modulus
                const getLimb: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p521.modulus
                const greaterEquals: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p521.modulus
                const halveM: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p521.modulus
                const initWith: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p521.modulus
                const inverseMod: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p521.modulus
                const ipv: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p521.modulus
                const limbs: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p521.modulus
                const maxMul: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p521.modulus
                const mod: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p521.modulus
                const montpowermod: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p521.modulus
                const mul: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p521.modulus
                const mulmod: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p521.modulus
                const normalize: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p521.modulus
                const placeVal: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p521.modulus
                const power: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p521.modulus
                const powermod: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p521.modulus
                const radix: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p521.modulus
                const radixMask: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p521.modulus
                const reduce: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p521.modulus
                const square: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p521.modulus
                const sub: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p521.modulus
                const subM: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p521.modulus
                const toBits: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p521.modulus
                const toString: any;

                // Too-deep object hierarchy from sjcl.bn.prime.p521.modulus
                const trim: any;

            }

        }

    }

}

export namespace cipher {
    class aes {
        constructor(key: any);

        decrypt(data: any): any;

        encrypt(data: any): any;

    }

}

export namespace ecc {
    class curve {
        field: any
        r: bn
        a: any
        b: any
        G: point
        constructor(Field: any, r: any, a: any, b: any, x: any, y: any);

        fromBits(bits: any): any;

    }

    class point {
        isIdentity: boolean
        x: bn
        y: bn
        curve: curve

        constructor(curve: any, x: any, y: any);

        constructor(curve: any);

        isValid(): any;

        mult(k: any): any;

        mult2(k: any, k2: any, affine2: any): any;

        multiples(): any;

        negate(): any;

        toBits(): any;

        toJac(): any;

    }

    class pointJac {
        constructor(curve: any, x: any, y: any, z: any);

        add(T: any): any;

        doubl(): any;

        isValid(): any;

        mult(k: any, affine: any): any;

        mult2(k1: any, affine: any, k2: any, affine2: any): any;

        negate(): any;

        toAffine(): any;

    }

    const curves: {
        c192: {
            G: {
                curve: any;
                isIdentity: boolean;
                isValid: any;
                mult: any;
                mult2: any;
                multiples: any;
                negate: any;
                toBits: any;
                toJac: any;
                x: {
                    add: any;
                    addM: any;
                    bitLength: any;
                    cnormalize: any;
                    copy: any;
                    doubleM: any;
                    equals: any;
                    exponent: number;
                    factor: number[];
                    fullFactor: number[];
                    fullMask: number;
                    fullOffset: number[];
                    fullReduce: any;
                    getLimb: any;
                    greaterEquals: any;
                    halveM: any;
                    initWith: any;
                    inverse: any;
                    inverseMod: any;
                    ipv: number;
                    limbs: number[];
                    maxMul: number;
                    minOffset: number;
                    mod: any;
                    modOffset: number;
                    modulus: {
                        add: any;
                        addM: any;
                        bitLength: any;
                        cnormalize: any;
                        copy: any;
                        doubleM: any;
                        equals: any;
                        fullReduce: any;
                        getLimb: any;
                        greaterEquals: any;
                        halveM: any;
                        initWith: any;
                        inverseMod: any;
                        ipv: number;
                        limbs: number[];
                        maxMul: number;
                        mod: any;
                        montpowermod: any;
                        mul: any;
                        mulmod: any;
                        normalize: any;
                        placeVal: number;
                        power: any;
                        powermod: any;
                        radix: number;
                        radixMask: number;
                        reduce: any;
                        square: any;
                        sub: any;
                        subM: any;
                        toBits: any;
                        toString: any;
                        trim: any;
                    };
                    montpowermod: any;
                    mul: any;
                    mulmod: any;
                    normalize: any;
                    offset: number[];
                    placeVal: number;
                    power: any;
                    powermod: any;
                    radix: number;
                    radixMask: number;
                    reduce: any;
                    square: any;
                    sub: any;
                    subM: any;
                    toBits: any;
                    toString: any;
                    trim: any;
                };
                y: {
                    add: any;
                    addM: any;
                    bitLength: any;
                    cnormalize: any;
                    copy: any;
                    doubleM: any;
                    equals: any;
                    exponent: number;
                    factor: number[];
                    fullFactor: number[];
                    fullMask: number;
                    fullOffset: number[];
                    fullReduce: any;
                    getLimb: any;
                    greaterEquals: any;
                    halveM: any;
                    initWith: any;
                    inverse: any;
                    inverseMod: any;
                    ipv: number;
                    limbs: number[];
                    maxMul: number;
                    minOffset: number;
                    mod: any;
                    modOffset: number;
                    modulus: {
                        add: any;
                        addM: any;
                        bitLength: any;
                        cnormalize: any;
                        copy: any;
                        doubleM: any;
                        equals: any;
                        fullReduce: any;
                        getLimb: any;
                        greaterEquals: any;
                        halveM: any;
                        initWith: any;
                        inverseMod: any;
                        ipv: number;
                        limbs: number[];
                        maxMul: number;
                        mod: any;
                        montpowermod: any;
                        mul: any;
                        mulmod: any;
                        normalize: any;
                        placeVal: number;
                        power: any;
                        powermod: any;
                        radix: number;
                        radixMask: number;
                        reduce: any;
                        square: any;
                        sub: any;
                        subM: any;
                        toBits: any;
                        toString: any;
                        trim: any;
                    };
                    montpowermod: any;
                    mul: any;
                    mulmod: any;
                    normalize: any;
                    offset: number[];
                    placeVal: number;
                    power: any;
                    powermod: any;
                    radix: number;
                    radixMask: number;
                    reduce: any;
                    square: any;
                    sub: any;
                    subM: any;
                    toBits: any;
                    toString: any;
                    trim: any;
                };
            };
            a: {
                add: any;
                addM: any;
                bitLength: any;
                cnormalize: any;
                copy: any;
                doubleM: any;
                equals: any;
                exponent: number;
                factor: number[];
                fullFactor: number[];
                fullMask: number;
                fullOffset: number[];
                fullReduce: any;
                getLimb: any;
                greaterEquals: any;
                halveM: any;
                initWith: any;
                inverse: any;
                inverseMod: any;
                ipv: number;
                limbs: number[];
                maxMul: number;
                minOffset: number;
                mod: any;
                modOffset: number;
                modulus: {
                    add: any;
                    addM: any;
                    bitLength: any;
                    cnormalize: any;
                    copy: any;
                    doubleM: any;
                    equals: any;
                    fullReduce: any;
                    getLimb: any;
                    greaterEquals: any;
                    halveM: any;
                    initWith: any;
                    inverseMod: any;
                    ipv: number;
                    limbs: number[];
                    maxMul: number;
                    mod: any;
                    montpowermod: any;
                    mul: any;
                    mulmod: any;
                    normalize: any;
                    placeVal: number;
                    power: any;
                    powermod: any;
                    radix: number;
                    radixMask: number;
                    reduce: any;
                    square: any;
                    sub: any;
                    subM: any;
                    toBits: any;
                    toString: any;
                    trim: any;
                };
                montpowermod: any;
                mul: any;
                mulmod: any;
                normalize: any;
                offset: number[];
                placeVal: number;
                power: any;
                powermod: any;
                radix: number;
                radixMask: number;
                reduce: any;
                square: any;
                sub: any;
                subM: any;
                toBits: any;
                toString: any;
                trim: any;
            };
            b: {
                add: any;
                addM: any;
                bitLength: any;
                cnormalize: any;
                copy: any;
                doubleM: any;
                equals: any;
                exponent: number;
                factor: number[];
                fullFactor: number[];
                fullMask: number;
                fullOffset: number[];
                fullReduce: any;
                getLimb: any;
                greaterEquals: any;
                halveM: any;
                initWith: any;
                inverse: any;
                inverseMod: any;
                ipv: number;
                limbs: number[];
                maxMul: number;
                minOffset: number;
                mod: any;
                modOffset: number;
                modulus: {
                    add: any;
                    addM: any;
                    bitLength: any;
                    cnormalize: any;
                    copy: any;
                    doubleM: any;
                    equals: any;
                    fullReduce: any;
                    getLimb: any;
                    greaterEquals: any;
                    halveM: any;
                    initWith: any;
                    inverseMod: any;
                    ipv: number;
                    limbs: number[];
                    maxMul: number;
                    mod: any;
                    montpowermod: any;
                    mul: any;
                    mulmod: any;
                    normalize: any;
                    placeVal: number;
                    power: any;
                    powermod: any;
                    radix: number;
                    radixMask: number;
                    reduce: any;
                    square: any;
                    sub: any;
                    subM: any;
                    toBits: any;
                    toString: any;
                    trim: any;
                };
                montpowermod: any;
                mul: any;
                mulmod: any;
                normalize: any;
                offset: number[];
                placeVal: number;
                power: any;
                powermod: any;
                radix: number;
                radixMask: number;
                reduce: any;
                square: any;
                sub: any;
                subM: any;
                toBits: any;
                toString: any;
                trim: any;
            };
            field: any;
            fromBits: any;
            r: {
                add: any;
                addM: any;
                bitLength: any;
                cnormalize: any;
                copy: any;
                doubleM: any;
                equals: any;
                fullReduce: any;
                getLimb: any;
                greaterEquals: any;
                halveM: any;
                initWith: any;
                inverseMod: any;
                ipv: number;
                limbs: number[];
                maxMul: number;
                mod: any;
                montpowermod: any;
                mul: any;
                mulmod: any;
                normalize: any;
                placeVal: number;
                power: any;
                powermod: any;
                radix: number;
                radixMask: number;
                reduce: any;
                square: any;
                sub: any;
                subM: any;
                toBits: any;
                toString: any;
                trim: any;
            };
        };
        c224: {
            G: {
                curve: any;
                isIdentity: boolean;
                isValid: any;
                mult: any;
                mult2: any;
                multiples: any;
                negate: any;
                toBits: any;
                toJac: any;
                x: {
                    add: any;
                    addM: any;
                    bitLength: any;
                    cnormalize: any;
                    copy: any;
                    doubleM: any;
                    equals: any;
                    exponent: number;
                    factor: number[];
                    fullFactor: number[];
                    fullMask: number;
                    fullOffset: number[];
                    fullReduce: any;
                    getLimb: any;
                    greaterEquals: any;
                    halveM: any;
                    initWith: any;
                    inverse: any;
                    inverseMod: any;
                    ipv: number;
                    limbs: number[];
                    maxMul: number;
                    minOffset: number;
                    mod: any;
                    modOffset: number;
                    modulus: {
                        add: any;
                        addM: any;
                        bitLength: any;
                        cnormalize: any;
                        copy: any;
                        doubleM: any;
                        equals: any;
                        fullReduce: any;
                        getLimb: any;
                        greaterEquals: any;
                        halveM: any;
                        initWith: any;
                        inverseMod: any;
                        ipv: number;
                        limbs: number[];
                        maxMul: number;
                        mod: any;
                        montpowermod: any;
                        mul: any;
                        mulmod: any;
                        normalize: any;
                        placeVal: number;
                        power: any;
                        powermod: any;
                        radix: number;
                        radixMask: number;
                        reduce: any;
                        square: any;
                        sub: any;
                        subM: any;
                        toBits: any;
                        toString: any;
                        trim: any;
                    };
                    montpowermod: any;
                    mul: any;
                    mulmod: any;
                    normalize: any;
                    offset: number[];
                    placeVal: number;
                    power: any;
                    powermod: any;
                    radix: number;
                    radixMask: number;
                    reduce: any;
                    square: any;
                    sub: any;
                    subM: any;
                    toBits: any;
                    toString: any;
                    trim: any;
                };
                y: {
                    add: any;
                    addM: any;
                    bitLength: any;
                    cnormalize: any;
                    copy: any;
                    doubleM: any;
                    equals: any;
                    exponent: number;
                    factor: number[];
                    fullFactor: number[];
                    fullMask: number;
                    fullOffset: number[];
                    fullReduce: any;
                    getLimb: any;
                    greaterEquals: any;
                    halveM: any;
                    initWith: any;
                    inverse: any;
                    inverseMod: any;
                    ipv: number;
                    limbs: number[];
                    maxMul: number;
                    minOffset: number;
                    mod: any;
                    modOffset: number;
                    modulus: {
                        add: any;
                        addM: any;
                        bitLength: any;
                        cnormalize: any;
                        copy: any;
                        doubleM: any;
                        equals: any;
                        fullReduce: any;
                        getLimb: any;
                        greaterEquals: any;
                        halveM: any;
                        initWith: any;
                        inverseMod: any;
                        ipv: number;
                        limbs: number[];
                        maxMul: number;
                        mod: any;
                        montpowermod: any;
                        mul: any;
                        mulmod: any;
                        normalize: any;
                        placeVal: number;
                        power: any;
                        powermod: any;
                        radix: number;
                        radixMask: number;
                        reduce: any;
                        square: any;
                        sub: any;
                        subM: any;
                        toBits: any;
                        toString: any;
                        trim: any;
                    };
                    montpowermod: any;
                    mul: any;
                    mulmod: any;
                    normalize: any;
                    offset: number[];
                    placeVal: number;
                    power: any;
                    powermod: any;
                    radix: number;
                    radixMask: number;
                    reduce: any;
                    square: any;
                    sub: any;
                    subM: any;
                    toBits: any;
                    toString: any;
                    trim: any;
                };
            };
            a: {
                add: any;
                addM: any;
                bitLength: any;
                cnormalize: any;
                copy: any;
                doubleM: any;
                equals: any;
                exponent: number;
                factor: number[];
                fullFactor: number[];
                fullMask: number;
                fullOffset: number[];
                fullReduce: any;
                getLimb: any;
                greaterEquals: any;
                halveM: any;
                initWith: any;
                inverse: any;
                inverseMod: any;
                ipv: number;
                limbs: number[];
                maxMul: number;
                minOffset: number;
                mod: any;
                modOffset: number;
                modulus: {
                    add: any;
                    addM: any;
                    bitLength: any;
                    cnormalize: any;
                    copy: any;
                    doubleM: any;
                    equals: any;
                    fullReduce: any;
                    getLimb: any;
                    greaterEquals: any;
                    halveM: any;
                    initWith: any;
                    inverseMod: any;
                    ipv: number;
                    limbs: number[];
                    maxMul: number;
                    mod: any;
                    montpowermod: any;
                    mul: any;
                    mulmod: any;
                    normalize: any;
                    placeVal: number;
                    power: any;
                    powermod: any;
                    radix: number;
                    radixMask: number;
                    reduce: any;
                    square: any;
                    sub: any;
                    subM: any;
                    toBits: any;
                    toString: any;
                    trim: any;
                };
                montpowermod: any;
                mul: any;
                mulmod: any;
                normalize: any;
                offset: number[];
                placeVal: number;
                power: any;
                powermod: any;
                radix: number;
                radixMask: number;
                reduce: any;
                square: any;
                sub: any;
                subM: any;
                toBits: any;
                toString: any;
                trim: any;
            };
            b: {
                add: any;
                addM: any;
                bitLength: any;
                cnormalize: any;
                copy: any;
                doubleM: any;
                equals: any;
                exponent: number;
                factor: number[];
                fullFactor: number[];
                fullMask: number;
                fullOffset: number[];
                fullReduce: any;
                getLimb: any;
                greaterEquals: any;
                halveM: any;
                initWith: any;
                inverse: any;
                inverseMod: any;
                ipv: number;
                limbs: number[];
                maxMul: number;
                minOffset: number;
                mod: any;
                modOffset: number;
                modulus: {
                    add: any;
                    addM: any;
                    bitLength: any;
                    cnormalize: any;
                    copy: any;
                    doubleM: any;
                    equals: any;
                    fullReduce: any;
                    getLimb: any;
                    greaterEquals: any;
                    halveM: any;
                    initWith: any;
                    inverseMod: any;
                    ipv: number;
                    limbs: number[];
                    maxMul: number;
                    mod: any;
                    montpowermod: any;
                    mul: any;
                    mulmod: any;
                    normalize: any;
                    placeVal: number;
                    power: any;
                    powermod: any;
                    radix: number;
                    radixMask: number;
                    reduce: any;
                    square: any;
                    sub: any;
                    subM: any;
                    toBits: any;
                    toString: any;
                    trim: any;
                };
                montpowermod: any;
                mul: any;
                mulmod: any;
                normalize: any;
                offset: number[];
                placeVal: number;
                power: any;
                powermod: any;
                radix: number;
                radixMask: number;
                reduce: any;
                square: any;
                sub: any;
                subM: any;
                toBits: any;
                toString: any;
                trim: any;
            };
            field: any;
            fromBits: any;
            r: {
                add: any;
                addM: any;
                bitLength: any;
                cnormalize: any;
                copy: any;
                doubleM: any;
                equals: any;
                fullReduce: any;
                getLimb: any;
                greaterEquals: any;
                halveM: any;
                initWith: any;
                inverseMod: any;
                ipv: number;
                limbs: number[];
                maxMul: number;
                mod: any;
                montpowermod: any;
                mul: any;
                mulmod: any;
                normalize: any;
                placeVal: number;
                power: any;
                powermod: any;
                radix: number;
                radixMask: number;
                reduce: any;
                square: any;
                sub: any;
                subM: any;
                toBits: any;
                toString: any;
                trim: any;
            };
        };
        c256: {
            G: {
                curve: any;
                isIdentity: boolean;
                isValid: any;
                mult: any;
                mult2: any;
                multiples: any;
                negate: any;
                toBits: any;
                toJac: any;
                x: {
                    add: any;
                    addM: any;
                    bitLength: any;
                    cnormalize: any;
                    copy: any;
                    doubleM: any;
                    equals: any;
                    exponent: number;
                    factor: number[];
                    fullFactor: number[];
                    fullMask: number;
                    fullOffset: number[];
                    fullReduce: any;
                    getLimb: any;
                    greaterEquals: any;
                    halveM: any;
                    initWith: any;
                    inverse: any;
                    inverseMod: any;
                    ipv: number;
                    limbs: number[];
                    maxMul: number;
                    minOffset: number;
                    mod: any;
                    modOffset: number;
                    modulus: {
                        add: any;
                        addM: any;
                        bitLength: any;
                        cnormalize: any;
                        copy: any;
                        doubleM: any;
                        equals: any;
                        fullReduce: any;
                        getLimb: any;
                        greaterEquals: any;
                        halveM: any;
                        initWith: any;
                        inverseMod: any;
                        ipv: number;
                        limbs: number[];
                        maxMul: number;
                        mod: any;
                        montpowermod: any;
                        mul: any;
                        mulmod: any;
                        normalize: any;
                        placeVal: number;
                        power: any;
                        powermod: any;
                        radix: number;
                        radixMask: number;
                        reduce: any;
                        square: any;
                        sub: any;
                        subM: any;
                        toBits: any;
                        toString: any;
                        trim: any;
                    };
                    montpowermod: any;
                    mul: any;
                    mulmod: any;
                    normalize: any;
                    offset: number[];
                    placeVal: number;
                    power: any;
                    powermod: any;
                    radix: number;
                    radixMask: number;
                    reduce: any;
                    square: any;
                    sub: any;
                    subM: any;
                    toBits: any;
                    toString: any;
                    trim: any;
                };
                y: {
                    add: any;
                    addM: any;
                    bitLength: any;
                    cnormalize: any;
                    copy: any;
                    doubleM: any;
                    equals: any;
                    exponent: number;
                    factor: number[];
                    fullFactor: number[];
                    fullMask: number;
                    fullOffset: number[];
                    fullReduce: any;
                    getLimb: any;
                    greaterEquals: any;
                    halveM: any;
                    initWith: any;
                    inverse: any;
                    inverseMod: any;
                    ipv: number;
                    limbs: number[];
                    maxMul: number;
                    minOffset: number;
                    mod: any;
                    modOffset: number;
                    modulus: {
                        add: any;
                        addM: any;
                        bitLength: any;
                        cnormalize: any;
                        copy: any;
                        doubleM: any;
                        equals: any;
                        fullReduce: any;
                        getLimb: any;
                        greaterEquals: any;
                        halveM: any;
                        initWith: any;
                        inverseMod: any;
                        ipv: number;
                        limbs: number[];
                        maxMul: number;
                        mod: any;
                        montpowermod: any;
                        mul: any;
                        mulmod: any;
                        normalize: any;
                        placeVal: number;
                        power: any;
                        powermod: any;
                        radix: number;
                        radixMask: number;
                        reduce: any;
                        square: any;
                        sub: any;
                        subM: any;
                        toBits: any;
                        toString: any;
                        trim: any;
                    };
                    montpowermod: any;
                    mul: any;
                    mulmod: any;
                    normalize: any;
                    offset: number[];
                    placeVal: number;
                    power: any;
                    powermod: any;
                    radix: number;
                    radixMask: number;
                    reduce: any;
                    square: any;
                    sub: any;
                    subM: any;
                    toBits: any;
                    toString: any;
                    trim: any;
                };
            };
            a: {
                add: any;
                addM: any;
                bitLength: any;
                cnormalize: any;
                copy: any;
                doubleM: any;
                equals: any;
                exponent: number;
                factor: number[];
                fullFactor: number[];
                fullMask: number;
                fullOffset: number[];
                fullReduce: any;
                getLimb: any;
                greaterEquals: any;
                halveM: any;
                initWith: any;
                inverse: any;
                inverseMod: any;
                ipv: number;
                limbs: number[];
                maxMul: number;
                minOffset: number;
                mod: any;
                modOffset: number;
                modulus: {
                    add: any;
                    addM: any;
                    bitLength: any;
                    cnormalize: any;
                    copy: any;
                    doubleM: any;
                    equals: any;
                    fullReduce: any;
                    getLimb: any;
                    greaterEquals: any;
                    halveM: any;
                    initWith: any;
                    inverseMod: any;
                    ipv: number;
                    limbs: number[];
                    maxMul: number;
                    mod: any;
                    montpowermod: any;
                    mul: any;
                    mulmod: any;
                    normalize: any;
                    placeVal: number;
                    power: any;
                    powermod: any;
                    radix: number;
                    radixMask: number;
                    reduce: any;
                    square: any;
                    sub: any;
                    subM: any;
                    toBits: any;
                    toString: any;
                    trim: any;
                };
                montpowermod: any;
                mul: any;
                mulmod: any;
                normalize: any;
                offset: number[];
                placeVal: number;
                power: any;
                powermod: any;
                radix: number;
                radixMask: number;
                reduce: any;
                square: any;
                sub: any;
                subM: any;
                toBits: any;
                toString: any;
                trim: any;
            };
            b: {
                add: any;
                addM: any;
                bitLength: any;
                cnormalize: any;
                copy: any;
                doubleM: any;
                equals: any;
                exponent: number;
                factor: number[];
                fullFactor: number[];
                fullMask: number;
                fullOffset: number[];
                fullReduce: any;
                getLimb: any;
                greaterEquals: any;
                halveM: any;
                initWith: any;
                inverse: any;
                inverseMod: any;
                ipv: number;
                limbs: number[];
                maxMul: number;
                minOffset: number;
                mod: any;
                modOffset: number;
                modulus: {
                    add: any;
                    addM: any;
                    bitLength: any;
                    cnormalize: any;
                    copy: any;
                    doubleM: any;
                    equals: any;
                    fullReduce: any;
                    getLimb: any;
                    greaterEquals: any;
                    halveM: any;
                    initWith: any;
                    inverseMod: any;
                    ipv: number;
                    limbs: number[];
                    maxMul: number;
                    mod: any;
                    montpowermod: any;
                    mul: any;
                    mulmod: any;
                    normalize: any;
                    placeVal: number;
                    power: any;
                    powermod: any;
                    radix: number;
                    radixMask: number;
                    reduce: any;
                    square: any;
                    sub: any;
                    subM: any;
                    toBits: any;
                    toString: any;
                    trim: any;
                };
                montpowermod: any;
                mul: any;
                mulmod: any;
                normalize: any;
                offset: number[];
                placeVal: number;
                power: any;
                powermod: any;
                radix: number;
                radixMask: number;
                reduce: any;
                square: any;
                sub: any;
                subM: any;
                toBits: any;
                toString: any;
                trim: any;
            };
            field: any;
            fromBits: any;
            r: {
                add: any;
                addM: any;
                bitLength: any;
                cnormalize: any;
                copy: any;
                doubleM: any;
                equals: any;
                fullReduce: any;
                getLimb: any;
                greaterEquals: any;
                halveM: any;
                initWith: any;
                inverseMod: any;
                ipv: number;
                limbs: number[];
                maxMul: number;
                mod: any;
                montpowermod: any;
                mul: any;
                mulmod: any;
                normalize: any;
                placeVal: number;
                power: any;
                powermod: any;
                radix: number;
                radixMask: number;
                reduce: any;
                square: any;
                sub: any;
                subM: any;
                toBits: any;
                toString: any;
                trim: any;
            };
        };
        c384: {
            G: {
                curve: any;
                isIdentity: boolean;
                isValid: any;
                mult: any;
                mult2: any;
                multiples: any;
                negate: any;
                toBits: any;
                toJac: any;
                x: {
                    add: any;
                    addM: any;
                    bitLength: any;
                    cnormalize: any;
                    copy: any;
                    doubleM: any;
                    equals: any;
                    exponent: number;
                    factor: number[];
                    fullFactor: number[];
                    fullMask: number;
                    fullOffset: number[];
                    fullReduce: any;
                    getLimb: any;
                    greaterEquals: any;
                    halveM: any;
                    initWith: any;
                    inverse: any;
                    inverseMod: any;
                    ipv: number;
                    limbs: number[];
                    maxMul: number;
                    minOffset: number;
                    mod: any;
                    modOffset: number;
                    modulus: {
                        add: any;
                        addM: any;
                        bitLength: any;
                        cnormalize: any;
                        copy: any;
                        doubleM: any;
                        equals: any;
                        fullReduce: any;
                        getLimb: any;
                        greaterEquals: any;
                        halveM: any;
                        initWith: any;
                        inverseMod: any;
                        ipv: number;
                        limbs: number[];
                        maxMul: number;
                        mod: any;
                        montpowermod: any;
                        mul: any;
                        mulmod: any;
                        normalize: any;
                        placeVal: number;
                        power: any;
                        powermod: any;
                        radix: number;
                        radixMask: number;
                        reduce: any;
                        square: any;
                        sub: any;
                        subM: any;
                        toBits: any;
                        toString: any;
                        trim: any;
                    };
                    montpowermod: any;
                    mul: any;
                    mulmod: any;
                    normalize: any;
                    offset: number[];
                    placeVal: number;
                    power: any;
                    powermod: any;
                    radix: number;
                    radixMask: number;
                    reduce: any;
                    square: any;
                    sub: any;
                    subM: any;
                    toBits: any;
                    toString: any;
                    trim: any;
                };
                y: {
                    add: any;
                    addM: any;
                    bitLength: any;
                    cnormalize: any;
                    copy: any;
                    doubleM: any;
                    equals: any;
                    exponent: number;
                    factor: number[];
                    fullFactor: number[];
                    fullMask: number;
                    fullOffset: number[];
                    fullReduce: any;
                    getLimb: any;
                    greaterEquals: any;
                    halveM: any;
                    initWith: any;
                    inverse: any;
                    inverseMod: any;
                    ipv: number;
                    limbs: number[];
                    maxMul: number;
                    minOffset: number;
                    mod: any;
                    modOffset: number;
                    modulus: {
                        add: any;
                        addM: any;
                        bitLength: any;
                        cnormalize: any;
                        copy: any;
                        doubleM: any;
                        equals: any;
                        fullReduce: any;
                        getLimb: any;
                        greaterEquals: any;
                        halveM: any;
                        initWith: any;
                        inverseMod: any;
                        ipv: number;
                        limbs: number[];
                        maxMul: number;
                        mod: any;
                        montpowermod: any;
                        mul: any;
                        mulmod: any;
                        normalize: any;
                        placeVal: number;
                        power: any;
                        powermod: any;
                        radix: number;
                        radixMask: number;
                        reduce: any;
                        square: any;
                        sub: any;
                        subM: any;
                        toBits: any;
                        toString: any;
                        trim: any;
                    };
                    montpowermod: any;
                    mul: any;
                    mulmod: any;
                    normalize: any;
                    offset: number[];
                    placeVal: number;
                    power: any;
                    powermod: any;
                    radix: number;
                    radixMask: number;
                    reduce: any;
                    square: any;
                    sub: any;
                    subM: any;
                    toBits: any;
                    toString: any;
                    trim: any;
                };
            };
            a: {
                add: any;
                addM: any;
                bitLength: any;
                cnormalize: any;
                copy: any;
                doubleM: any;
                equals: any;
                exponent: number;
                factor: number[];
                fullFactor: number[];
                fullMask: number;
                fullOffset: number[];
                fullReduce: any;
                getLimb: any;
                greaterEquals: any;
                halveM: any;
                initWith: any;
                inverse: any;
                inverseMod: any;
                ipv: number;
                limbs: number[];
                maxMul: number;
                minOffset: number;
                mod: any;
                modOffset: number;
                modulus: {
                    add: any;
                    addM: any;
                    bitLength: any;
                    cnormalize: any;
                    copy: any;
                    doubleM: any;
                    equals: any;
                    fullReduce: any;
                    getLimb: any;
                    greaterEquals: any;
                    halveM: any;
                    initWith: any;
                    inverseMod: any;
                    ipv: number;
                    limbs: number[];
                    maxMul: number;
                    mod: any;
                    montpowermod: any;
                    mul: any;
                    mulmod: any;
                    normalize: any;
                    placeVal: number;
                    power: any;
                    powermod: any;
                    radix: number;
                    radixMask: number;
                    reduce: any;
                    square: any;
                    sub: any;
                    subM: any;
                    toBits: any;
                    toString: any;
                    trim: any;
                };
                montpowermod: any;
                mul: any;
                mulmod: any;
                normalize: any;
                offset: number[];
                placeVal: number;
                power: any;
                powermod: any;
                radix: number;
                radixMask: number;
                reduce: any;
                square: any;
                sub: any;
                subM: any;
                toBits: any;
                toString: any;
                trim: any;
            };
            b: {
                add: any;
                addM: any;
                bitLength: any;
                cnormalize: any;
                copy: any;
                doubleM: any;
                equals: any;
                exponent: number;
                factor: number[];
                fullFactor: number[];
                fullMask: number;
                fullOffset: number[];
                fullReduce: any;
                getLimb: any;
                greaterEquals: any;
                halveM: any;
                initWith: any;
                inverse: any;
                inverseMod: any;
                ipv: number;
                limbs: number[];
                maxMul: number;
                minOffset: number;
                mod: any;
                modOffset: number;
                modulus: {
                    add: any;
                    addM: any;
                    bitLength: any;
                    cnormalize: any;
                    copy: any;
                    doubleM: any;
                    equals: any;
                    fullReduce: any;
                    getLimb: any;
                    greaterEquals: any;
                    halveM: any;
                    initWith: any;
                    inverseMod: any;
                    ipv: number;
                    limbs: number[];
                    maxMul: number;
                    mod: any;
                    montpowermod: any;
                    mul: any;
                    mulmod: any;
                    normalize: any;
                    placeVal: number;
                    power: any;
                    powermod: any;
                    radix: number;
                    radixMask: number;
                    reduce: any;
                    square: any;
                    sub: any;
                    subM: any;
                    toBits: any;
                    toString: any;
                    trim: any;
                };
                montpowermod: any;
                mul: any;
                mulmod: any;
                normalize: any;
                offset: number[];
                placeVal: number;
                power: any;
                powermod: any;
                radix: number;
                radixMask: number;
                reduce: any;
                square: any;
                sub: any;
                subM: any;
                toBits: any;
                toString: any;
                trim: any;
            };
            field: any;
            fromBits: any;
            r: {
                add: any;
                addM: any;
                bitLength: any;
                cnormalize: any;
                copy: any;
                doubleM: any;
                equals: any;
                fullReduce: any;
                getLimb: any;
                greaterEquals: any;
                halveM: any;
                initWith: any;
                inverseMod: any;
                ipv: number;
                limbs: number[];
                maxMul: number;
                mod: any;
                montpowermod: any;
                mul: any;
                mulmod: any;
                normalize: any;
                placeVal: number;
                power: any;
                powermod: any;
                radix: number;
                radixMask: number;
                reduce: any;
                square: any;
                sub: any;
                subM: any;
                toBits: any;
                toString: any;
                trim: any;
            };
        };
        c521: {
            G: {
                curve: any;
                isIdentity: boolean;
                isValid: any;
                mult: any;
                mult2: any;
                multiples: any;
                negate: any;
                toBits: any;
                toJac: any;
                x: {
                    add: any;
                    addM: any;
                    bitLength: any;
                    cnormalize: any;
                    copy: any;
                    doubleM: any;
                    equals: any;
                    exponent: number;
                    factor: number[];
                    fullFactor: number[];
                    fullMask: number;
                    fullOffset: number[];
                    fullReduce: any;
                    getLimb: any;
                    greaterEquals: any;
                    halveM: any;
                    initWith: any;
                    inverse: any;
                    inverseMod: any;
                    ipv: number;
                    limbs: number[];
                    maxMul: number;
                    minOffset: number;
                    mod: any;
                    modOffset: number;
                    modulus: {
                        add: any;
                        addM: any;
                        bitLength: any;
                        cnormalize: any;
                        copy: any;
                        doubleM: any;
                        equals: any;
                        fullReduce: any;
                        getLimb: any;
                        greaterEquals: any;
                        halveM: any;
                        initWith: any;
                        inverseMod: any;
                        ipv: number;
                        limbs: number[];
                        maxMul: number;
                        mod: any;
                        montpowermod: any;
                        mul: any;
                        mulmod: any;
                        normalize: any;
                        placeVal: number;
                        power: any;
                        powermod: any;
                        radix: number;
                        radixMask: number;
                        reduce: any;
                        square: any;
                        sub: any;
                        subM: any;
                        toBits: any;
                        toString: any;
                        trim: any;
                    };
                    montpowermod: any;
                    mul: any;
                    mulmod: any;
                    normalize: any;
                    offset: number[];
                    placeVal: number;
                    power: any;
                    powermod: any;
                    radix: number;
                    radixMask: number;
                    reduce: any;
                    square: any;
                    sub: any;
                    subM: any;
                    toBits: any;
                    toString: any;
                    trim: any;
                };
                y: {
                    add: any;
                    addM: any;
                    bitLength: any;
                    cnormalize: any;
                    copy: any;
                    doubleM: any;
                    equals: any;
                    exponent: number;
                    factor: number[];
                    fullFactor: number[];
                    fullMask: number;
                    fullOffset: number[];
                    fullReduce: any;
                    getLimb: any;
                    greaterEquals: any;
                    halveM: any;
                    initWith: any;
                    inverse: any;
                    inverseMod: any;
                    ipv: number;
                    limbs: number[];
                    maxMul: number;
                    minOffset: number;
                    mod: any;
                    modOffset: number;
                    modulus: {
                        add: any;
                        addM: any;
                        bitLength: any;
                        cnormalize: any;
                        copy: any;
                        doubleM: any;
                        equals: any;
                        fullReduce: any;
                        getLimb: any;
                        greaterEquals: any;
                        halveM: any;
                        initWith: any;
                        inverseMod: any;
                        ipv: number;
                        limbs: number[];
                        maxMul: number;
                        mod: any;
                        montpowermod: any;
                        mul: any;
                        mulmod: any;
                        normalize: any;
                        placeVal: number;
                        power: any;
                        powermod: any;
                        radix: number;
                        radixMask: number;
                        reduce: any;
                        square: any;
                        sub: any;
                        subM: any;
                        toBits: any;
                        toString: any;
                        trim: any;
                    };
                    montpowermod: any;
                    mul: any;
                    mulmod: any;
                    normalize: any;
                    offset: number[];
                    placeVal: number;
                    power: any;
                    powermod: any;
                    radix: number;
                    radixMask: number;
                    reduce: any;
                    square: any;
                    sub: any;
                    subM: any;
                    toBits: any;
                    toString: any;
                    trim: any;
                };
            };
            a: {
                add: any;
                addM: any;
                bitLength: any;
                cnormalize: any;
                copy: any;
                doubleM: any;
                equals: any;
                exponent: number;
                factor: number[];
                fullFactor: number[];
                fullMask: number;
                fullOffset: number[];
                fullReduce: any;
                getLimb: any;
                greaterEquals: any;
                halveM: any;
                initWith: any;
                inverse: any;
                inverseMod: any;
                ipv: number;
                limbs: number[];
                maxMul: number;
                minOffset: number;
                mod: any;
                modOffset: number;
                modulus: {
                    add: any;
                    addM: any;
                    bitLength: any;
                    cnormalize: any;
                    copy: any;
                    doubleM: any;
                    equals: any;
                    fullReduce: any;
                    getLimb: any;
                    greaterEquals: any;
                    halveM: any;
                    initWith: any;
                    inverseMod: any;
                    ipv: number;
                    limbs: number[];
                    maxMul: number;
                    mod: any;
                    montpowermod: any;
                    mul: any;
                    mulmod: any;
                    normalize: any;
                    placeVal: number;
                    power: any;
                    powermod: any;
                    radix: number;
                    radixMask: number;
                    reduce: any;
                    square: any;
                    sub: any;
                    subM: any;
                    toBits: any;
                    toString: any;
                    trim: any;
                };
                montpowermod: any;
                mul: any;
                mulmod: any;
                normalize: any;
                offset: number[];
                placeVal: number;
                power: any;
                powermod: any;
                radix: number;
                radixMask: number;
                reduce: any;
                square: any;
                sub: any;
                subM: any;
                toBits: any;
                toString: any;
                trim: any;
            };
            b: {
                add: any;
                addM: any;
                bitLength: any;
                cnormalize: any;
                copy: any;
                doubleM: any;
                equals: any;
                exponent: number;
                factor: number[];
                fullFactor: number[];
                fullMask: number;
                fullOffset: number[];
                fullReduce: any;
                getLimb: any;
                greaterEquals: any;
                halveM: any;
                initWith: any;
                inverse: any;
                inverseMod: any;
                ipv: number;
                limbs: number[];
                maxMul: number;
                minOffset: number;
                mod: any;
                modOffset: number;
                modulus: {
                    add: any;
                    addM: any;
                    bitLength: any;
                    cnormalize: any;
                    copy: any;
                    doubleM: any;
                    equals: any;
                    fullReduce: any;
                    getLimb: any;
                    greaterEquals: any;
                    halveM: any;
                    initWith: any;
                    inverseMod: any;
                    ipv: number;
                    limbs: number[];
                    maxMul: number;
                    mod: any;
                    montpowermod: any;
                    mul: any;
                    mulmod: any;
                    normalize: any;
                    placeVal: number;
                    power: any;
                    powermod: any;
                    radix: number;
                    radixMask: number;
                    reduce: any;
                    square: any;
                    sub: any;
                    subM: any;
                    toBits: any;
                    toString: any;
                    trim: any;
                };
                montpowermod: any;
                mul: any;
                mulmod: any;
                normalize: any;
                offset: number[];
                placeVal: number;
                power: any;
                powermod: any;
                radix: number;
                radixMask: number;
                reduce: any;
                square: any;
                sub: any;
                subM: any;
                toBits: any;
                toString: any;
                trim: any;
            };
            field: any;
            fromBits: any;
            r: {
                add: any;
                addM: any;
                bitLength: any;
                cnormalize: any;
                copy: any;
                doubleM: any;
                equals: any;
                fullReduce: any;
                getLimb: any;
                greaterEquals: any;
                halveM: any;
                initWith: any;
                inverseMod: any;
                ipv: number;
                limbs: number[];
                maxMul: number;
                mod: any;
                montpowermod: any;
                mul: any;
                mulmod: any;
                normalize: any;
                placeVal: number;
                power: any;
                powermod: any;
                radix: number;
                radixMask: number;
                reduce: any;
                square: any;
                sub: any;
                subM: any;
                toBits: any;
                toString: any;
                trim: any;
            };
        };
        k192: {
            G: {
                curve: any;
                isIdentity: boolean;
                isValid: any;
                mult: any;
                mult2: any;
                multiples: any;
                negate: any;
                toBits: any;
                toJac: any;
                x: {
                    add: any;
                    addM: any;
                    bitLength: any;
                    cnormalize: any;
                    copy: any;
                    doubleM: any;
                    equals: any;
                    exponent: number;
                    factor: number[];
                    fullFactor: number[];
                    fullMask: number;
                    fullOffset: number[];
                    fullReduce: any;
                    getLimb: any;
                    greaterEquals: any;
                    halveM: any;
                    initWith: any;
                    inverse: any;
                    inverseMod: any;
                    ipv: number;
                    limbs: number[];
                    maxMul: number;
                    minOffset: number;
                    mod: any;
                    modOffset: number;
                    modulus: {
                        add: any;
                        addM: any;
                        bitLength: any;
                        cnormalize: any;
                        copy: any;
                        doubleM: any;
                        equals: any;
                        fullReduce: any;
                        getLimb: any;
                        greaterEquals: any;
                        halveM: any;
                        initWith: any;
                        inverseMod: any;
                        ipv: number;
                        limbs: number[];
                        maxMul: number;
                        mod: any;
                        montpowermod: any;
                        mul: any;
                        mulmod: any;
                        normalize: any;
                        placeVal: number;
                        power: any;
                        powermod: any;
                        radix: number;
                        radixMask: number;
                        reduce: any;
                        square: any;
                        sub: any;
                        subM: any;
                        toBits: any;
                        toString: any;
                        trim: any;
                    };
                    montpowermod: any;
                    mul: any;
                    mulmod: any;
                    normalize: any;
                    offset: number[];
                    placeVal: number;
                    power: any;
                    powermod: any;
                    radix: number;
                    radixMask: number;
                    reduce: any;
                    square: any;
                    sub: any;
                    subM: any;
                    toBits: any;
                    toString: any;
                    trim: any;
                };
                y: {
                    add: any;
                    addM: any;
                    bitLength: any;
                    cnormalize: any;
                    copy: any;
                    doubleM: any;
                    equals: any;
                    exponent: number;
                    factor: number[];
                    fullFactor: number[];
                    fullMask: number;
                    fullOffset: number[];
                    fullReduce: any;
                    getLimb: any;
                    greaterEquals: any;
                    halveM: any;
                    initWith: any;
                    inverse: any;
                    inverseMod: any;
                    ipv: number;
                    limbs: number[];
                    maxMul: number;
                    minOffset: number;
                    mod: any;
                    modOffset: number;
                    modulus: {
                        add: any;
                        addM: any;
                        bitLength: any;
                        cnormalize: any;
                        copy: any;
                        doubleM: any;
                        equals: any;
                        fullReduce: any;
                        getLimb: any;
                        greaterEquals: any;
                        halveM: any;
                        initWith: any;
                        inverseMod: any;
                        ipv: number;
                        limbs: number[];
                        maxMul: number;
                        mod: any;
                        montpowermod: any;
                        mul: any;
                        mulmod: any;
                        normalize: any;
                        placeVal: number;
                        power: any;
                        powermod: any;
                        radix: number;
                        radixMask: number;
                        reduce: any;
                        square: any;
                        sub: any;
                        subM: any;
                        toBits: any;
                        toString: any;
                        trim: any;
                    };
                    montpowermod: any;
                    mul: any;
                    mulmod: any;
                    normalize: any;
                    offset: number[];
                    placeVal: number;
                    power: any;
                    powermod: any;
                    radix: number;
                    radixMask: number;
                    reduce: any;
                    square: any;
                    sub: any;
                    subM: any;
                    toBits: any;
                    toString: any;
                    trim: any;
                };
            };
            a: {
                add: any;
                addM: any;
                bitLength: any;
                cnormalize: any;
                copy: any;
                doubleM: any;
                equals: any;
                exponent: number;
                factor: number[];
                fullFactor: number[];
                fullMask: number;
                fullOffset: number[];
                fullReduce: any;
                getLimb: any;
                greaterEquals: any;
                halveM: any;
                initWith: any;
                inverse: any;
                inverseMod: any;
                ipv: number;
                limbs: number[];
                maxMul: number;
                minOffset: number;
                mod: any;
                modOffset: number;
                modulus: {
                    add: any;
                    addM: any;
                    bitLength: any;
                    cnormalize: any;
                    copy: any;
                    doubleM: any;
                    equals: any;
                    fullReduce: any;
                    getLimb: any;
                    greaterEquals: any;
                    halveM: any;
                    initWith: any;
                    inverseMod: any;
                    ipv: number;
                    limbs: number[];
                    maxMul: number;
                    mod: any;
                    montpowermod: any;
                    mul: any;
                    mulmod: any;
                    normalize: any;
                    placeVal: number;
                    power: any;
                    powermod: any;
                    radix: number;
                    radixMask: number;
                    reduce: any;
                    square: any;
                    sub: any;
                    subM: any;
                    toBits: any;
                    toString: any;
                    trim: any;
                };
                montpowermod: any;
                mul: any;
                mulmod: any;
                normalize: any;
                offset: number[];
                placeVal: number;
                power: any;
                powermod: any;
                radix: number;
                radixMask: number;
                reduce: any;
                square: any;
                sub: any;
                subM: any;
                toBits: any;
                toString: any;
                trim: any;
            };
            b: {
                add: any;
                addM: any;
                bitLength: any;
                cnormalize: any;
                copy: any;
                doubleM: any;
                equals: any;
                exponent: number;
                factor: number[];
                fullFactor: number[];
                fullMask: number;
                fullOffset: number[];
                fullReduce: any;
                getLimb: any;
                greaterEquals: any;
                halveM: any;
                initWith: any;
                inverse: any;
                inverseMod: any;
                ipv: number;
                limbs: number[];
                maxMul: number;
                minOffset: number;
                mod: any;
                modOffset: number;
                modulus: {
                    add: any;
                    addM: any;
                    bitLength: any;
                    cnormalize: any;
                    copy: any;
                    doubleM: any;
                    equals: any;
                    fullReduce: any;
                    getLimb: any;
                    greaterEquals: any;
                    halveM: any;
                    initWith: any;
                    inverseMod: any;
                    ipv: number;
                    limbs: number[];
                    maxMul: number;
                    mod: any;
                    montpowermod: any;
                    mul: any;
                    mulmod: any;
                    normalize: any;
                    placeVal: number;
                    power: any;
                    powermod: any;
                    radix: number;
                    radixMask: number;
                    reduce: any;
                    square: any;
                    sub: any;
                    subM: any;
                    toBits: any;
                    toString: any;
                    trim: any;
                };
                montpowermod: any;
                mul: any;
                mulmod: any;
                normalize: any;
                offset: number[];
                placeVal: number;
                power: any;
                powermod: any;
                radix: number;
                radixMask: number;
                reduce: any;
                square: any;
                sub: any;
                subM: any;
                toBits: any;
                toString: any;
                trim: any;
            };
            field: any;
            fromBits: any;
            r: {
                add: any;
                addM: any;
                bitLength: any;
                cnormalize: any;
                copy: any;
                doubleM: any;
                equals: any;
                fullReduce: any;
                getLimb: any;
                greaterEquals: any;
                halveM: any;
                initWith: any;
                inverseMod: any;
                ipv: number;
                limbs: number[];
                maxMul: number;
                mod: any;
                montpowermod: any;
                mul: any;
                mulmod: any;
                normalize: any;
                placeVal: number;
                power: any;
                powermod: any;
                radix: number;
                radixMask: number;
                reduce: any;
                square: any;
                sub: any;
                subM: any;
                toBits: any;
                toString: any;
                trim: any;
            };
        };
        k224: {
            G: {
                curve: any;
                isIdentity: boolean;
                isValid: any;
                mult: any;
                mult2: any;
                multiples: any;
                negate: any;
                toBits: any;
                toJac: any;
                x: {
                    add: any;
                    addM: any;
                    bitLength: any;
                    cnormalize: any;
                    copy: any;
                    doubleM: any;
                    equals: any;
                    exponent: number;
                    factor: number[];
                    fullFactor: number[];
                    fullMask: number;
                    fullOffset: number[];
                    fullReduce: any;
                    getLimb: any;
                    greaterEquals: any;
                    halveM: any;
                    initWith: any;
                    inverse: any;
                    inverseMod: any;
                    ipv: number;
                    limbs: number[];
                    maxMul: number;
                    minOffset: number;
                    mod: any;
                    modOffset: number;
                    modulus: {
                        add: any;
                        addM: any;
                        bitLength: any;
                        cnormalize: any;
                        copy: any;
                        doubleM: any;
                        equals: any;
                        fullReduce: any;
                        getLimb: any;
                        greaterEquals: any;
                        halveM: any;
                        initWith: any;
                        inverseMod: any;
                        ipv: number;
                        limbs: number[];
                        maxMul: number;
                        mod: any;
                        montpowermod: any;
                        mul: any;
                        mulmod: any;
                        normalize: any;
                        placeVal: number;
                        power: any;
                        powermod: any;
                        radix: number;
                        radixMask: number;
                        reduce: any;
                        square: any;
                        sub: any;
                        subM: any;
                        toBits: any;
                        toString: any;
                        trim: any;
                    };
                    montpowermod: any;
                    mul: any;
                    mulmod: any;
                    normalize: any;
                    offset: number[];
                    placeVal: number;
                    power: any;
                    powermod: any;
                    radix: number;
                    radixMask: number;
                    reduce: any;
                    square: any;
                    sub: any;
                    subM: any;
                    toBits: any;
                    toString: any;
                    trim: any;
                };
                y: {
                    add: any;
                    addM: any;
                    bitLength: any;
                    cnormalize: any;
                    copy: any;
                    doubleM: any;
                    equals: any;
                    exponent: number;
                    factor: number[];
                    fullFactor: number[];
                    fullMask: number;
                    fullOffset: number[];
                    fullReduce: any;
                    getLimb: any;
                    greaterEquals: any;
                    halveM: any;
                    initWith: any;
                    inverse: any;
                    inverseMod: any;
                    ipv: number;
                    limbs: number[];
                    maxMul: number;
                    minOffset: number;
                    mod: any;
                    modOffset: number;
                    modulus: {
                        add: any;
                        addM: any;
                        bitLength: any;
                        cnormalize: any;
                        copy: any;
                        doubleM: any;
                        equals: any;
                        fullReduce: any;
                        getLimb: any;
                        greaterEquals: any;
                        halveM: any;
                        initWith: any;
                        inverseMod: any;
                        ipv: number;
                        limbs: number[];
                        maxMul: number;
                        mod: any;
                        montpowermod: any;
                        mul: any;
                        mulmod: any;
                        normalize: any;
                        placeVal: number;
                        power: any;
                        powermod: any;
                        radix: number;
                        radixMask: number;
                        reduce: any;
                        square: any;
                        sub: any;
                        subM: any;
                        toBits: any;
                        toString: any;
                        trim: any;
                    };
                    montpowermod: any;
                    mul: any;
                    mulmod: any;
                    normalize: any;
                    offset: number[];
                    placeVal: number;
                    power: any;
                    powermod: any;
                    radix: number;
                    radixMask: number;
                    reduce: any;
                    square: any;
                    sub: any;
                    subM: any;
                    toBits: any;
                    toString: any;
                    trim: any;
                };
            };
            a: {
                add: any;
                addM: any;
                bitLength: any;
                cnormalize: any;
                copy: any;
                doubleM: any;
                equals: any;
                exponent: number;
                factor: number[];
                fullFactor: number[];
                fullMask: number;
                fullOffset: number[];
                fullReduce: any;
                getLimb: any;
                greaterEquals: any;
                halveM: any;
                initWith: any;
                inverse: any;
                inverseMod: any;
                ipv: number;
                limbs: number[];
                maxMul: number;
                minOffset: number;
                mod: any;
                modOffset: number;
                modulus: {
                    add: any;
                    addM: any;
                    bitLength: any;
                    cnormalize: any;
                    copy: any;
                    doubleM: any;
                    equals: any;
                    fullReduce: any;
                    getLimb: any;
                    greaterEquals: any;
                    halveM: any;
                    initWith: any;
                    inverseMod: any;
                    ipv: number;
                    limbs: number[];
                    maxMul: number;
                    mod: any;
                    montpowermod: any;
                    mul: any;
                    mulmod: any;
                    normalize: any;
                    placeVal: number;
                    power: any;
                    powermod: any;
                    radix: number;
                    radixMask: number;
                    reduce: any;
                    square: any;
                    sub: any;
                    subM: any;
                    toBits: any;
                    toString: any;
                    trim: any;
                };
                montpowermod: any;
                mul: any;
                mulmod: any;
                normalize: any;
                offset: number[];
                placeVal: number;
                power: any;
                powermod: any;
                radix: number;
                radixMask: number;
                reduce: any;
                square: any;
                sub: any;
                subM: any;
                toBits: any;
                toString: any;
                trim: any;
            };
            b: {
                add: any;
                addM: any;
                bitLength: any;
                cnormalize: any;
                copy: any;
                doubleM: any;
                equals: any;
                exponent: number;
                factor: number[];
                fullFactor: number[];
                fullMask: number;
                fullOffset: number[];
                fullReduce: any;
                getLimb: any;
                greaterEquals: any;
                halveM: any;
                initWith: any;
                inverse: any;
                inverseMod: any;
                ipv: number;
                limbs: number[];
                maxMul: number;
                minOffset: number;
                mod: any;
                modOffset: number;
                modulus: {
                    add: any;
                    addM: any;
                    bitLength: any;
                    cnormalize: any;
                    copy: any;
                    doubleM: any;
                    equals: any;
                    fullReduce: any;
                    getLimb: any;
                    greaterEquals: any;
                    halveM: any;
                    initWith: any;
                    inverseMod: any;
                    ipv: number;
                    limbs: number[];
                    maxMul: number;
                    mod: any;
                    montpowermod: any;
                    mul: any;
                    mulmod: any;
                    normalize: any;
                    placeVal: number;
                    power: any;
                    powermod: any;
                    radix: number;
                    radixMask: number;
                    reduce: any;
                    square: any;
                    sub: any;
                    subM: any;
                    toBits: any;
                    toString: any;
                    trim: any;
                };
                montpowermod: any;
                mul: any;
                mulmod: any;
                normalize: any;
                offset: number[];
                placeVal: number;
                power: any;
                powermod: any;
                radix: number;
                radixMask: number;
                reduce: any;
                square: any;
                sub: any;
                subM: any;
                toBits: any;
                toString: any;
                trim: any;
            };
            field: any;
            fromBits: any;
            r: {
                add: any;
                addM: any;
                bitLength: any;
                cnormalize: any;
                copy: any;
                doubleM: any;
                equals: any;
                fullReduce: any;
                getLimb: any;
                greaterEquals: any;
                halveM: any;
                initWith: any;
                inverseMod: any;
                ipv: number;
                limbs: number[];
                maxMul: number;
                mod: any;
                montpowermod: any;
                mul: any;
                mulmod: any;
                normalize: any;
                placeVal: number;
                power: any;
                powermod: any;
                radix: number;
                radixMask: number;
                reduce: any;
                square: any;
                sub: any;
                subM: any;
                toBits: any;
                toString: any;
                trim: any;
            };
        };
        k256: {
            G: {
                curve: any;
                isIdentity: boolean;
                isValid: any;
                mult: any;
                mult2: any;
                multiples: any;
                negate: any;
                toBits: any;
                toJac: any;
                x: {
                    add: any;
                    addM: any;
                    bitLength: any;
                    cnormalize: any;
                    copy: any;
                    doubleM: any;
                    equals: any;
                    exponent: number;
                    factor: number[];
                    fullFactor: number[];
                    fullMask: number;
                    fullOffset: number[];
                    fullReduce: any;
                    getLimb: any;
                    greaterEquals: any;
                    halveM: any;
                    initWith: any;
                    inverse: any;
                    inverseMod: any;
                    ipv: number;
                    limbs: number[];
                    maxMul: number;
                    minOffset: number;
                    mod: any;
                    modOffset: number;
                    modulus: {
                        add: any;
                        addM: any;
                        bitLength: any;
                        cnormalize: any;
                        copy: any;
                        doubleM: any;
                        equals: any;
                        fullReduce: any;
                        getLimb: any;
                        greaterEquals: any;
                        halveM: any;
                        initWith: any;
                        inverseMod: any;
                        ipv: number;
                        limbs: number[];
                        maxMul: number;
                        mod: any;
                        montpowermod: any;
                        mul: any;
                        mulmod: any;
                        normalize: any;
                        placeVal: number;
                        power: any;
                        powermod: any;
                        radix: number;
                        radixMask: number;
                        reduce: any;
                        square: any;
                        sub: any;
                        subM: any;
                        toBits: any;
                        toString: any;
                        trim: any;
                    };
                    montpowermod: any;
                    mul: any;
                    mulmod: any;
                    normalize: any;
                    offset: number[];
                    placeVal: number;
                    power: any;
                    powermod: any;
                    radix: number;
                    radixMask: number;
                    reduce: any;
                    square: any;
                    sub: any;
                    subM: any;
                    toBits: any;
                    toString: any;
                    trim: any;
                };
                y: {
                    add: any;
                    addM: any;
                    bitLength: any;
                    cnormalize: any;
                    copy: any;
                    doubleM: any;
                    equals: any;
                    exponent: number;
                    factor: number[];
                    fullFactor: number[];
                    fullMask: number;
                    fullOffset: number[];
                    fullReduce: any;
                    getLimb: any;
                    greaterEquals: any;
                    halveM: any;
                    initWith: any;
                    inverse: any;
                    inverseMod: any;
                    ipv: number;
                    limbs: number[];
                    maxMul: number;
                    minOffset: number;
                    mod: any;
                    modOffset: number;
                    modulus: {
                        add: any;
                        addM: any;
                        bitLength: any;
                        cnormalize: any;
                        copy: any;
                        doubleM: any;
                        equals: any;
                        fullReduce: any;
                        getLimb: any;
                        greaterEquals: any;
                        halveM: any;
                        initWith: any;
                        inverseMod: any;
                        ipv: number;
                        limbs: number[];
                        maxMul: number;
                        mod: any;
                        montpowermod: any;
                        mul: any;
                        mulmod: any;
                        normalize: any;
                        placeVal: number;
                        power: any;
                        powermod: any;
                        radix: number;
                        radixMask: number;
                        reduce: any;
                        square: any;
                        sub: any;
                        subM: any;
                        toBits: any;
                        toString: any;
                        trim: any;
                    };
                    montpowermod: any;
                    mul: any;
                    mulmod: any;
                    normalize: any;
                    offset: number[];
                    placeVal: number;
                    power: any;
                    powermod: any;
                    radix: number;
                    radixMask: number;
                    reduce: any;
                    square: any;
                    sub: any;
                    subM: any;
                    toBits: any;
                    toString: any;
                    trim: any;
                };
            };
            a: {
                add: any;
                addM: any;
                bitLength: any;
                cnormalize: any;
                copy: any;
                doubleM: any;
                equals: any;
                exponent: number;
                factor: number[];
                fullFactor: number[];
                fullMask: number;
                fullOffset: number[];
                fullReduce: any;
                getLimb: any;
                greaterEquals: any;
                halveM: any;
                initWith: any;
                inverse: any;
                inverseMod: any;
                ipv: number;
                limbs: number[];
                maxMul: number;
                minOffset: number;
                mod: any;
                modOffset: number;
                modulus: {
                    add: any;
                    addM: any;
                    bitLength: any;
                    cnormalize: any;
                    copy: any;
                    doubleM: any;
                    equals: any;
                    fullReduce: any;
                    getLimb: any;
                    greaterEquals: any;
                    halveM: any;
                    initWith: any;
                    inverseMod: any;
                    ipv: number;
                    limbs: number[];
                    maxMul: number;
                    mod: any;
                    montpowermod: any;
                    mul: any;
                    mulmod: any;
                    normalize: any;
                    placeVal: number;
                    power: any;
                    powermod: any;
                    radix: number;
                    radixMask: number;
                    reduce: any;
                    square: any;
                    sub: any;
                    subM: any;
                    toBits: any;
                    toString: any;
                    trim: any;
                };
                montpowermod: any;
                mul: any;
                mulmod: any;
                normalize: any;
                offset: number[];
                placeVal: number;
                power: any;
                powermod: any;
                radix: number;
                radixMask: number;
                reduce: any;
                square: any;
                sub: any;
                subM: any;
                toBits: any;
                toString: any;
                trim: any;
            };
            b: {
                add: any;
                addM: any;
                bitLength: any;
                cnormalize: any;
                copy: any;
                doubleM: any;
                equals: any;
                exponent: number;
                factor: number[];
                fullFactor: number[];
                fullMask: number;
                fullOffset: number[];
                fullReduce: any;
                getLimb: any;
                greaterEquals: any;
                halveM: any;
                initWith: any;
                inverse: any;
                inverseMod: any;
                ipv: number;
                limbs: number[];
                maxMul: number;
                minOffset: number;
                mod: any;
                modOffset: number;
                modulus: {
                    add: any;
                    addM: any;
                    bitLength: any;
                    cnormalize: any;
                    copy: any;
                    doubleM: any;
                    equals: any;
                    fullReduce: any;
                    getLimb: any;
                    greaterEquals: any;
                    halveM: any;
                    initWith: any;
                    inverseMod: any;
                    ipv: number;
                    limbs: number[];
                    maxMul: number;
                    mod: any;
                    montpowermod: any;
                    mul: any;
                    mulmod: any;
                    normalize: any;
                    placeVal: number;
                    power: any;
                    powermod: any;
                    radix: number;
                    radixMask: number;
                    reduce: any;
                    square: any;
                    sub: any;
                    subM: any;
                    toBits: any;
                    toString: any;
                    trim: any;
                };
                montpowermod: any;
                mul: any;
                mulmod: any;
                normalize: any;
                offset: number[];
                placeVal: number;
                power: any;
                powermod: any;
                radix: number;
                radixMask: number;
                reduce: any;
                square: any;
                sub: any;
                subM: any;
                toBits: any;
                toString: any;
                trim: any;
            };
            field: any;
            fromBits: any;
            r: {
                add: any;
                addM: any;
                bitLength: any;
                cnormalize: any;
                copy: any;
                doubleM: any;
                equals: any;
                fullReduce: any;
                getLimb: any;
                greaterEquals: any;
                halveM: any;
                initWith: any;
                inverseMod: any;
                ipv: number;
                limbs: number[];
                maxMul: number;
                mod: any;
                montpowermod: any;
                mul: any;
                mulmod: any;
                normalize: any;
                placeVal: number;
                power: any;
                powermod: any;
                radix: number;
                radixMask: number;
                reduce: any;
                square: any;
                sub: any;
                subM: any;
                toBits: any;
                toString: any;
                trim: any;
            };
        };
    };

    function curveName(curve: any): any;

    function deserialize(key: any): any;

    namespace basicKey {
        function generateKeys(cn: any): any;

        function publicKey(curve: any, point: any): any;

        function secretKey(curve: any, exponent: any): any;

    }

    namespace ecdsa {
        class publicKey {
            constructor(curve: any, point: any, ...args: any[]);

            getType(): any;

            verify(hash: any, rs: any, fakeLegacyVersion: any): any;

        }

        class secretKey {
            constructor(curve: any, exponent: any, ...args: any[]);

            getType(): any;

            sign(hash: any, paranoia: any, fakeLegacyVersion: any, fixedKForTesting: any): any;

        }

        function generateKeys(curve: any, paranoia: any, sec: any): any;

    }

    namespace elGamal {
        class publicKey {
            constructor(curve: any, point: any, ...args: any[]);

            getType(): any;

            kem(paranoia: any): any;

        }

        class secretKey {
            constructor(curve: any, exponent: any, ...args: any[]);

            dh(pk: any): any;

            dhJavaEc(pk: any): any;

            getType(): any;

            unkem(tag: any): any;

        }

        function generateKeys(curve: any, paranoia: any, sec: any): any;

    }

}

export namespace exception {
    function bug(message: any): any;

    function corrupt(message: any): any;

    function invalid(message: any): any;

    function notReady(message: any): any;

}

export namespace hash {
    class sha256 {
        constructor(hash: any);

        finalize(): any;

        reset(): any;

        update(data: any): any;

        static hash(data: any): any;

    }

}

export namespace json {
    const defaults: {
        adata: string;
        cipher: string;
        iter: number;
        ks: number;
        mode: string;
        ts: number;
        v: number;
    };

    function decode(str: any): any;

    function decrypt(password: any, ciphertext: any, params: any, rp: any): any;

    function encode(obj: any): any;

    function encrypt(password: any, plaintext: any, params: any, rp: any, ...args: any[]): any;

}

export namespace misc {
    class hmac {
        constructor(key: any, Hash: any);

        digest(): any;

        encrypt(data: any): any;

        mac(data: any): any;

        reset(): void;

        update(data: any): void;

    }

    function cachedPbkdf2(password: any, obj: any): any;

    function pbkdf2(password: any, salt: any, count: any, length: any, Prff: any): any;

}

export namespace random {
    function addEntropy(data: any, estimatedEntropy: any, source: any): void;

    function addEventListener(name: any, callback: any): void;

    function getProgress(paranoia: any): any;

    function isReady(paranoia: any): any;

    function randomWords(nwords: any, paranoia: any): any;

    function removeEventListener(name: any, cb: any): void;

    function setDefaultParanoia(paranoia: any, allowZeroParanoia: any): void;

    function startCollectors(): void;

    function stopCollectors(): void;

}

